* How to set up Cider

If you're having the following problem

#+begin_src 
nrepl-send-sync-request: Wrong type argument
#+end_src

https://gitter.im/syl20bnr/spacemacs/archives/2018/12/16

#+begin_quote
kouvas @kouvas Dec 16 2018 15:23
anyone knows why i get error "Wrong type argument: strings, nil" when I try to evaluate a Clojure code block in org-mode? I have loaded clojure and python org-label support in userconfig but only python works fine
^"... stringp, nil"

yuhan0 @yuhan0 Dec 16 2018 15:28
Unless I'm mistaken, the org file has to be inside a clojure project with cider already jacked in
Is that the case for you? The error message could definitely be more informative in that regard

kouvas @kouvas Dec 16 2018 15:39
executing Clojure code block...
nrepl-send-sync-request: Wrong type argument: stringp, nil
you are right :) forgot to check the message buffer
so there is not other way? I would like to use a general clojure org file for note taking and examples

Compro Prasad @Compro-Prasad Dec 16 2018 15:40
you can check where the error is coming from
use M-x toggle-debug-on-error
#+end_quote

https://cider.readthedocs.io/en/latest/up_and_running/

https://github.com/technomancy/leiningen/blob/stable/doc/TUTORIAL.md

brew install leiningen

* DONE Adding Clojure to your App
  CLOSED: [2019-10-24 Thu 17:26]
** DONE Understanding Clojure & the REPL
   CLOSED: [2019-10-20 Sun 10:58]

(First technically add the clojure jars to your project)

Clojure in most cases is always the REPL.
Although it's possible to compile out clojure code to Java classes as seen here https://www.innoq.com/en/blog/native-clojure-and-graalvm/
this is not generally how code is run.
Therefore you always start a REPL on the JVM and then load clojure code.
This can _also_ be done in a server/client way using something like nRepl.

This is a good introduction to both repls and nrepl
https://lambdaisland.com/guides/clojure-repls/clojure-repls


Further nRepl links
https://github.com/clojure/tools.nrepl
https://nrepl.org/nrepl/0.6.0/index.html

The following is interesting tools
https://stackoverflow.com/questions/26743958/why-cant-i-print-from-background-threads-in-clojure-cider-repl-in-emacs

Starting with Clojure for a Java programmer: https://youtu.be/P76Vbsk_3J0?t=2936
** DONE Set up a repl in your program
   CLOSED: [2019-09-25 Wed 23:07]

NOTE The following is out of date:
  https://gist.github.com/mbobesic/bbdea9a1fae1927057b8

See https://github.com/nrepl/nrepl
https://mvnrepository.com/artifact/nrepl/nrepl/0.6.0

Remember to add clojars as the repository.
#+begin_src 
repositories {
  maven { url "https://clojars.org/repo" }
}
#+end_src


Also pay attention to 
https://clojure.org/reference/java_interop#_calling_clojure_from_java

and the rest of the page in general for tips on interop.
** DONE Connect to an existing repl
   CLOSED: [2019-09-25 Wed 23:06]
 https://practicalli.github.io/spacemacs/clojure-repl/connect-to-running-repl.html

 As the guide above states:
 #+begin_src 
 M-x cider-connect ;; Then type in host and port number
 [nREPL] Establishing direct connection to localhost:8083 ...
 [nREPL] Direct connection to localhost:8083 established
 #+end_src
** DONE Accessing the buffer
   CLOSED: [2019-09-25 Wed 23:05]

Now see the following, but ignore the Vim bindings and look for the emacs ones lower on the page.
https://practicalli.github.io/spacemacs/clojure-repl/switching-to-repl.html

Note that if you connect from a .clj file that is linked to another buffer or more stringent
still, is a clojure project, then you won't be able to immediately go to the buffer with the 
command M-x cider-switch-to-repl-buffer.

Switch to the nRepl with [C-x b] as appropriate.

Note that with Spacemacs the [C-x b] may cut off the buffer name.
#+begin_src 
;; The default of 20 cuts off clojure repl buffer information helpful to locate it.
  (setq helm-buffer-max-length 30)
#+end_src

The above isn't a complete fix because the file name is too long still!
However you can filter the list by port number with [C-x b] by typing the port number even if you cannot see it!
** DONE Cannot print to stdout of original executing program
   CLOSED: [2019-10-20 Sun 16:50]
 But when we try and print to system out of our running programming where-in the REPL is launched from

 #+begin_src 
 user> (println "Hello world")
 Hello world
 nil
 user>
 #+end_src

NOTE The standard out comes out via Cider and not the originating program.

Make sure you read the nrepl help link listed in the first section.

However the following will use the applications System.out

#+begin_src 
(.println (System/out) "hi")
#+end_src

However once the cider-nrepl is plugged in it might stop working again
https://github.com/clojure-emacs/cider-nrepl/blob/master/src/cider/nrepl/middleware/out.clj

This is by design. Instead try the following if logging is on the classpath.

#+begin_src 
(. (. org.slf4j.LoggerFactory getLogger "Test logger") info "Test Message")
#+end_src


** DONE Getting your project up to scratch with Gradle
   CLOSED: [2019-10-24 Thu 00:34]
Given we're starting with a Gradle project we could look to include something like this
https://github.com/clojurephant/clojurephant


#+begin_comment
What happens if you try to add compilation directories manually:
Or https://discuss.gradle.org/t/add-to-dependencies-classpath/7281/10
Not a good idea because this appears not to be a source set, 
and IntelliJ is confused about file paths something like
https://stackoverflow.com/questions/30577665/disable-intellij-source-root-inspection
#+end_comment

However clojurephant may rely on latest version of gradle or you'll get the following:
 #+begin_src 
 org.gradle.internal.exceptions.LocationAwareException: Build file '/Users/dmg46664/IdeaProjects/precollate/build.gradle' line: 19
 An exception occurred applying plugin request [id: 'dev.clojurephant.clojure', version: '0.5.0-alpha.5']
	 at org.gradle.plugin.use.internal.DefaultPluginRequestApplicator.applyPlugin(DefaultPluginRequestApplicator.java:232)
	 at java.lang.Thread.run(Thread.java:748)
 Caused by: org.gradle.api.plugins.InvalidPluginException: An exception occurred applying plugin request [id: 'dev.clojurephant.clojure', version: '0.5.0-alpha.5']
	 at org.gradle.plugin.use.internal.DefaultPluginRequestApplicator.exceptionOccurred(DefaultPluginRequestApplicator.java:247)
	 at org.gradle.plugin.use.internal.DefaultPluginRequestApplicator.applyPlugin(DefaultPluginRequestApplicator.java:229)
	 ... 105 more
 Caused by: org.gradle.api.internal.plugins.PluginApplicationException: Failed to apply plugin [class 'dev.clojurephant.plugin.clojure.ClojureBasePlugin']
	 at org.gradle.api.internal.plugins.DefaultPluginManager.doApply(DefaultPluginManager.java:160)
	 at org.gradle.api.internal.plugins.DefaultPluginManager.addImperativePlugin(DefaultPluginManager.java:85)

	 at org.gradle.api.internal.plugins.DefaultPluginManager.apply(DefaultPluginManager.java:130)
	 at org.gradle.plugin.use.internal.DefaultPluginRequestApplicator$3.run(DefaultPluginRequestApplicator.java:151)
	 at org.gradle.plugin.use.internal.DefaultPluginRequestApplicator.applyPlugin(DefaultPluginRequestApplicator.java:225)
	 ... 105 more
 Caused by: java.lang.NoSuchMethodError: org.gradle.api.model.ObjectFactory.directoryProperty()Lorg/gradle/api/file/DirectoryProperty;
	 at dev.clojurephant.plugin.clojure.ClojureExtension.<init>(ClojureExtension.java:13)
	 at dev.clojurephant.plugin.clojure.ClojureExtension_Decorated.<init>(Unknown Source)
	 at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
	 at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)
	 at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)
	 at java.lang.reflect.Constructor.newInstance(Constructor.java:423)
	 at org.gradle.internal.reflect.DirectInstantiator.newInstance(DirectInstantiator.java:51)
	 ... 146 more


 #+end_src

For Mac, be aware of upgrading bash for sdkman, and then sdkman updgrade gradle.
https://merikan.com/2019/04/upgrade-to-bash-5-in-macos/

You may still have problems connecting from Emacs Cider, to a separate application.
(It should work if jack'ing in from Leiningen or build systems that support passing dependencies)
https://github.com/clojurephant/clojurephant/issues/78

In order to get around this use a cider nrepl handler
https://docs.cider.mx/cider-nrepl/usage.html#_via_embedding_nrepl_in_your_app
https://clojars.org/cider/cider-nrepl

** DONE Hotloading your own files
   CLOSED: [2019-10-24 Thu 00:36]

The first problem is to make sure when you invoke Clojure that it can see local script files.
If you've got clojure onto the classpath AND your local files onto the classpath (See clojurephant in the previous sections), then you should be able to do the following:

#+begin_src 
      require.invoke(Clojure.read("accounts.localscript"));
      IFn localscript = Clojure.var("accounts.localscript", "hello-world");
      localscript.invoke();
#+end_src

src/main/clojure/accounts/localscript.clj
#+begin_src 
(ns accounts.localscript)

(defn hello-world []
  (println "Hello world"))
#+end_src


** TODO Refactoring not working via NREPL & clojurephant

See everything written up here:
https://github.com/clojurephant/clojurephant/issues/131

https://github.com/clojure-emacs/clj-refactor.el#setup
#+begin_src 
On the other hand if a standalone REPL or an embedded nREPL server is used you will need to manually add this dependency (see below).

Either in your project's project.clj or in the :user profile found at ~/.lein/profiles.clj:

:plugins [[refactor-nrepl "2.4.0"]
          [Cider/cider-nrepl "0.18.0"]]
#+end_src

So added to clojurephant

#+begin_src 
implementation 'refactor-nrepl:refactor-nrepl:2.4.0'
#+end_src

But still getting the following error
#+begin_src 
WARNING: clj-refactor and refactor-nrepl are out of sync.
Their versions are 2.5.0-SNAPSHOT (package: 20190618.716) and n/a, respectively.
You can mute this warning by changing cljr-suppress-middleware-warnings.
#+end_src

Interesting:
https://github.com/clojure-emacs/cider/issues/2511#issuecomment-435767772

Some background on the warning https://github.com/clojure-emacs/clj-refactor.el/pull/392
https://github.com/clojure-emacs/cider/pull/2238

Trying to find out more about instantiating middleware:
https://cljdoc.org/d/nrepl/nrepl/0.5.3/doc/design/middleware

Strategy might be to look at how boot manually instantiates middleware and try and do the same
- https://clojuredocs.org/clojure.core/swap!

Need to add understanding about nrepl and piggie backing.
https://github.com/nrepl/piggieback#embedded



See this stack of advice:
https://docs.cider.mx/cider-nrepl/usage.html#_via_embedding_nrepl_in_your_app
which links to 
https://github.com/clojure-emacs/cider-nrepl/issues/447
which references:
https://github.com/clojure-emacs/cider-nrepl/issues/464


** TODO Why does autocompletion not work?

https://github.com/clojure-emacs/cider/issues/2528

** DONE Getting started with Deps.edn
   CLOSED: [2020-01-05 Sun 13:42]
Tutorial:
https://www.youtube.com/watch?v=SPSn02RxpxM

which tracks this larger blog tutorial:
https://practicalli.github.io/blog/posts/clojure-web-server-cli-tools-deps-edn/

Starting a new project:
https://github.com/seancorfield/clj-new#getting-started

Create a basic application:
#+begin_src 
    clj -A:new app myname/myapp
    cd myapp
    clj -m myname.myapp
#+end_src

Starting repl in cider https://youtu.be/SPSn02RxpxM?t=3848

** TODO Adding REBL to lein and cider

#+begin_src
Execution error (FileNotFoundException) at cognitect.rebl.impl.monaco/loading (monaco.clj:3).
Could not locate cljfmt/core__init.class, cljfmt/core.clj or cljfmt/core.cljc on classpath.
ERROR: Unhandled REPL handler exception processing message {:nrepl.middleware.print/stream? 1, :nrepl.middleware.print/print cider.nrepl.pprint/pprint, :nrepl.middleware.print/quota 1048576, :nrepl.middleware.print/options {:right-margin 80}, :op stacktrace, :session 33d17ac2-413a-48d7-a8b4-37425257220f, :id 23}
java.lang.NoClassDefFoundError: Could not initialize class cognitect.rebl.ui__init
	at java.base/java.lang.Class.forName0(Native Method)
	at java.base/java.lang.Class.forName(Class.java:416)
	at clojure.lang.RT.classForName(RT.java:2207)
	at clojure.lang.RT.classForName(RT.java:2216)
	at clojure.lang.Compiler.maybeResolveIn(Compiler.java:7437)
	at clojure.core$ns_resolve.invokeStatic(core.clj:4370)
	at clojure.core$ns_resolve.invokeStatic(core.clj:4359)
	at clojure.core$ns_resolve.invoke(core.clj:4359)
	at cider.nrepl.inlined_deps.orchard.v0v5v5.orchard.java$resolve_class$fn__8010.invoke(java.clj:310)
	at cider.nrepl.inlined_deps.orchard.v0v5v5.orchard.java$resolve_class.invokeStatic(java.clj:310)
#+end_src

Or from the terminal after upgrading lein to 2.9.3

#+begin_src 
lein repl
dmg46664.etl=> (require '[cognitect.rebl :as rebl])
nil
dmg46664.etl=> (rebl/ui)
Execution error (FileNotFoundException) at cognitect.rebl.impl.monaco/loading (monaco.clj:3).
Could not locate cljfmt/core__init.class, cljfmt/core.clj or cljfmt/core.cljc on classpath.
#+end_src

Might want to try https://github.com/RickMoynihan/nrebl.middleware

Perhaps it doesn't work with symlinks of the jar?
Adding the dependency as per comment here fixes this https://github.com/cognitect-labs/REBL-distro/issues/34

* Clojure assistance

** Refactoring
*** C-c C-m rs     To call rs functions.
All functions in clj-refactor have a two-letter mnemonic shortcut. E.g. rs for cljr-rename-symbol. 
Given the prefix choice in the example setup you'd call this function by hitting 
https://github.com/clojure-emacs/clj-refactor.el/wiki
** Importing libraries
https://8thlight.com/blog/colin-jones/2010/12/05/clojure-libs-and-namespaces-require-use-import-and-ns.html
&
https://stackoverflow.com/questions/10358149/in-clojure-1-4-what-is-the-use-of-refer-within-require/10370672

How to import and require gen-classes
https://groups.google.com/forum/#!topic/clojure/9_xkNUEsgIc

Also
https://github.com/yogthos/clojure-error-message-catalog/blob/master/clj/class-not-found-exception.md

More on class loaders
https://www.baeldung.com/java-classloaders

** Quoting and unbound function errors
https://8thlight.com/blog/colin-jones/2012/05/22/quoting-without-confusion.html
** Destructuring
http://blog.brunobonacci.com/2014/11/16/clojure-complete-guide-to-destructuring/

https://stackoverflow.com/questions/3337888/clojure-named-arguments
** Forum topics
*** Clojure spec greedy operators https://clojurians-log.clojureverse.org/clojure-spec/2018-01-04
** Tutorials
Great tutorial in coverage, but a little tedious is mode and development.
https://www.youtube.com/watch?v=ciGyHkDuPAE
*** Protocols! Must watch https://www.youtube.com/watch?v=kQhOlWXXl2I
*** Clojure script on react with figwheel https://medium.com/mindorks/building-mobile-apps-ios-and-android-with-clojurescript-4600235f826c
*** Clojurescript with ReactNative https://medium.com/upwork-engineering/developing-react-native-applications-in-clojurescript-9386b1cd5869
Basically start here:
https://cljsrn.org/
https://github.com/drapanjanas/re-natal
*** TODO Datomic migration  https://grishaev.me/en/pg-to-datomic/
*** TODO Building an ANKI clone using datomic https://www.youtube.com/watch?v=QrSnTIHotZE
** Useful clojure titbits
*** Apply vs Map https://stackoverflow.com/questions/2311528/clojure-apply-vs-map
*** Incrementing i https://stackoverflow.com/questions/4513078/i-equivalent-in-clojure
  also note the atom and swap example?

See map-indexed for a solution
 https://stackoverflow.com/questions/24798831/clojure-increment-a-counter
https://clojuredocs.org/clojure.core/map-indexed
https://clojuredocs.org/clojure.core/dissoc
*** Odd examples https://stackoverflow.com/questions/44052252/what-does-clojure-function-jerry-means
*** Two dots https://clojure.org/reference/java_interop#_the_dot_special_form
*** doseq vs for (lazy)  https://stackoverflow.com/questions/4725417/difference-between-doseq-and-for-in-clojure
https://blog.jeaye.com/2016/07/27/clojure-for/

Tip. See the combination of doseq and map-index  https://github.com/mjul/docjure/blob/master/src/dk/ative/docjure/spreadsheet.clj#L267
*** Reading wierd clojure characters https://clojure.org/guides/weird_characters
*** Add index to a vector of maps (assoc & map-index) https://stackoverflow.com/questions/34490944/clojure-add-index-to-vector-of-maps
*** Converting non lazy sequences (2nd answer)  https://stackoverflow.com/a/1645224/93074
*** Prototyping https://grishaev.me/en/clj-args/
*** How to download clojuredocs documentation offline
#+begin_src 
wget -k -m http://clojuredocs.org/
#+end_src

- In the css and cljs direcories, rename all the .js and .css files to end in precisely this suffix.


#+begin_src python
import SimpleHTTPServer
import SocketServer

PORT = 1234

class Handler(SimpleHTTPServer.SimpleHTTPRequestHandler):
    pass

Handler.extensions_map[''] = 'text/html'

httpd = SocketServer.TCPServer(("", PORT), Handler)

print "serving at port", PORT
httpd.serve_forever()
#+end_src

#+begin_src 
python server.py
#+end_src

https://docs.python.org/3/library/http.server.html
**** TODO Find a way so that the server shows pages without the .html in html format. This could be either with python or 
https://github.com/ring-clojure/ring/wiki/Getting-Started
*** TODO How do Clojure return types work?
https://clojuredocs.org/clojure.core/doall

#+begin_src clojure
(def t (map inc [1 2 3]))
(type t) ; => clojure.lang.LazySeq

(type (seq '(1 2 3)))
(type '(1 2 3))

(doall t) ; => (2 3 4)
(str (doall t)) ; => clojure.lang.LazySeq
(str (vector t)) ; => [(2 3 4)]
(str (first (vector (doall t)))) ; => clojure.lang.LazySeq

(def x (str (vector t)))
(println x)




(str "test")
(println t)

(do
  (map inc [1 2 3])
  )

#+end_src
*** Testing in clojure
Need an intro guide to testing your app with the repl?
Say you're Repl'ing your app and you want to run a test on a function change. How do you do this?

Some background.
https://stackoverflow.com/questions/21294294/run-tests-from-clojure-repl-and-leiningen
*** Last repl exception  https://clojuredocs.org/clojure.core/*e
*** Exercise to visualize functional: 
Have the user write code that takes records and tranforms it to legacy api.
I.e. takes a map, and has to take a dynamic list of excel columns
and put that data into a record in those columns, perhaps accommodating for different types:
i.e. formulas dates and values.
This should help the student understand the difference between creating data vs. walking over
the data tree maintaining state.
*** TODO Another exercise

; figure out how get the following to return a simple list.

; Excercise
(genSummaryHeaders ["BTC" "EUR" "ETH" "GBP"] ["EUR"])
; Should return ("Date" "Summary" "BTC" "BTC Balance" ... same for other currencies "EUR fee")
; Or a vector
** Spec & generative testing
*** Spec and test.check guides

https://clojure.org/guides/spec
https://clojure.org/guides/test_check_beginner

The spec guide introduces testing check fns for testing fn defs.
Hint: Rather first test functions with property tests and see where those simply port over to the simpler variety.

See the following for generators
https://github.com/clojure/test.check/blob/master/doc/generator-examples.md
*** Difference between gen/fmap & gen/bind


gen/fmap. 

Every time this generator is asked to generate it: 
- generates a new value from the generator argument.
- Uses the value to prepare a new non-generator value to return.
- This generator is therefore a new fmap which produces these values.
- You can see below that it still calls the generator argument each time to fill out this vector

#+begin_src clojure
(gen/generate
 (gen/vector (gen/fmap (fn [x] (list x)) (gen/choose 1 5)))
 )
[(2) (4) (3) (4) (5) (4) (1) (3) (5) (1) (1) (2) (2) (3)]
#+end_src

gen/bind also:
- Uses the generator argument to generate values each time it is called. I.e. below is not equal.

#+begin_src clojure
(gen/generate (gen/bind (gen/vector gen/large-integer 3)
                        (fn [xs] (gen/vector (gen/shuffle xs) 2))))
[[0 28057239 -45698] [0 28057239 -45698]]

;; The vector of large ints will not be exploded, and still be a generator
;; that shuffle will work on.
(gen/generate (gen/vector (gen/shuffle (gen/vector gen/large-integer 3)) 2))
[[[:gen #function[clojure.test.check.generators/gen-fmap/fn--405]]]
 [[:gen #function[clojure.test.check.generators/gen-fmap/fn--405]]]]

;; Adding a generate is the equivalent of bind. I.e. it locks/binds the values at this point.
(gen/generate (gen/vector (gen/shuffle
                           (gen/generate (gen/vector gen/large-integer 3))) 2))

#+end_src

- However for bind, these values are used merely as arguments to a new generators (or a composition of generators) and the user of gen/bind must return this generator.

Note also how gen/let works
#+begin_src clojure
(gen/generate
 (gen/let 
 [n (gen/vector gen/small-integer 3)] ;; here the output of an iteration is bound.
   (gen/vector (gen/elements n)))) ;; however gen/elements here is not bound and so the vector is able to generate random items
[7 7 7 -2 -20 -20 -20 -20 7]

(gen/generate
 (gen/let [n (gen/vector gen/small-integer 3)
           e (gen/elements n) ;; However compared to the above, here elements is bound!
           v (gen/vector (gen/return e))] ;;It makes the example different, but regardless see how we are only aboe to get a single value.
   v))
[-15 -15 -15 -15 -15 -15]


;; However NOTE that the whole let block produces a generator, for which each call
;; is independent!!! this means that for below, although like the above examples a vector of 3
;; ints is generated and elements are selected from it.. each time the vector requires a new value
;; a new list of 3 small ints is generated and so the result is simply a random list!
(gen/generate
 (gen/vector
  (gen/let [n (gen/vector gen/small-integer 3)
            e (gen/elements n)]
    e)))
[-17 -6 1 -14 0 -25 17 -21 -26 -6 -2 -13 -5 27 -7 19]

#+end_src
*** s/gen gotcha overriding map values

#+begin_src clojure
;; In 'ns'
(s/def ::spec (s/keys :req-un [::field]))

;; In other ns
(s/gen ::spec {
[::ns/field] #(gen/return :override) ;; Won't work! Presumably because ::spec is :req-un (but didn't test)
[:field] #(gen/return :override2) ;; Works!
})
#+end_src
*** A vector of something as a fn argument https://stackoverflow.com/questions/43230546/a-clojure-spec-that-matches-and-generates-an-ordered-vector-of-variable-length

Example of Lack of expessivity out the box.

In order to understand Alex's answer, you'll need to understand gen/fmap.
Read the following as mandatory first https://clojure.org/guides/test_check_beginner
NOTE Some of the examples here are incorrect if using
[clojure.spec.gen.alpha :as gen]

(fmap as a name is a little misleading as it doesn't map the function to each item provided,
but runs the function with the result of the generator as an argument, bundling the result in 
another generator)

Then the example from comment in question, highlights further nuances
#+begin_src clojure
(s/def ::pattern (s/cat :sym symbol? :str string? :kws (s/* keyword?))) 
(s/def ::pattern-2 (s/cat :s string? :p ::pattern)) 
(s/valid? ::pattern ['af "5" :key]) 
;; true 
(s/valid? ::pattern-2 ["string" 'af "5" :key]) 
;; true 
(s/def ::pattern-3 (s/cat :s string? :p ::solution)) 
(s/valid? ::pattern-3 ["string" 'af "5" :key]) 
;; false !!! <- we are losing flatness 
(s/valid? ::pattern-3 ["string" ['af "5" :key]]) 
;; true !!! <- we are losing flatness 
#+end_src
*** Common problem with spec. Cryptic error messages
**** Spec : nil TODO but why?
     Check the REPL for more information

#+begin_src clojure
 [clojure.spec.alpha :as s]
 [clojure.spec.gen.alpha :as gen]

gen/generate (s/gen ::coinbase-trade)) ;; should get only the generator in question as nothing has been added, even though it's already defined with-gen


1. Unhandled clojure.lang.ExceptionInfo
   Spec assertion failed.

         Spec: nil
        Value: nil

     Problems: 

                 alpha.clj:  282  clojure.spec.alpha/gensub
                 alpha.clj:  272  clojure.spec.alpha/gensub
                 alpha.clj:  877  clojure.spec.alpha/map-spec-impl/reify/rgen
                  core.clj: 2760  clojure.core/map/fn
              LazySeq.java:   42  clojure.lang.LazySeq/sval
              LazySeq.java:   51  clojure.lang.LazySeq/seq
                   RT.java:  531  clojure.lang.RT/seq
                  core.clj:  137  clojure.core/seq
                  core.clj: 2746  clojure.core/map/fn
              LazySeq.java:   42  clojure.lang.LazySeq/sval
              LazySeq.java:   51  clojure.lang.LazySeq/seq
#+end_src

You'll then see
#+begin_src 
Execution error (ExceptionInfo) at dmg46664.etl/eval16178 (form-init16923224181612635633.clj:413).
Unable to construct gen at: [:dmg46664.etl/date] for: :dmg46664.etl/date
#+end_src
**** class clojure.test.check.generators.Generator cannot be cast to class
Using (s/with-gen) with (gen/fmap) and not wrapping fmap in no-args function?

#+begin_src 
1. Unhandled java.lang.ClassCastException
   class clojure.test.check.generators.Generator cannot be cast to class
   clojure.lang.IFn (clojure.test.check.generators.Generator is in unnamed
   module of loader clojure.lang.DynamicClassLoader @218a78f6; clojure.lang.IFn
   is in unnamed module of loader 'app')

                 alpha.clj:  936  clojure.spec.alpha/spec-impl/reify
                 alpha.clj:  279  clojure.spec.alpha/gensub
                 alpha.clj:  272  clojure.spec.alpha/gensub
                 alpha.clj:  296  clojure.spec.alpha/gen
#+end_src
**** Wrong number of args (1) passed to: clojure.spec.alpha/def
Problem starting the REPL, 
None of my own code in the stacktrace

It turned out to be one of the standard defs. Wierd!? Why didn't it give me a line number?
It had nothing to do with test.check.generator/gen vs spec.gen.alpha/gen
*** Niggles
- In order to do generative testing, the generators will often need to be at the level of the
container and not at the record level. Testing date aggregation code isn't so useful, if you
never generate records that share the same date. 
- This is mis-sold when learning about spec
as if defining structures let's 
*** Test check api issues overriding generators
https://stackoverflow.com/questions/55436961/clojure-spec-override-check-generator-for-predicate
*** Clojure spec for parsing https://juxt.pro/blog/posts/parsing-with-clojure-spec.html
Doesn't scale because no tokenization.
*** Look at plugin project to see another limitation of spec.
*** What is rose-tree in test.check?
http://blog.guillermowinkler.com/blog/2015/04/12/verifying-state-machine-behavior-using-test-dot-check/
*** Exercise. Write a generator that selects 2 values from a list (and then use it).

A wasteful implementation

#+begin_src clojure
;; TODO It would be nice to remove the such-that as it's wasteful
(defn choose2 [g] (gen/such-that (fn [[x y]] (not= x y))
                                 (gen/let [x g
                                           y g]
                                   [x y])))
#+end_src

But you can't use it in gen/let

#+begin_src clojure
(gen/let [currencies (choose2 (gen/elements ["BTC" "EUR" "GBP"]))
           buy (first currencies) ;;NOTE fails here. Currencies is a generator, not a vector
           sell (second currencies)
           trade (s/gen ::trade
                        {
                         [::buyCurrency] #(buy)
                         [::sellCurrency] #(sell)
                         })]
   trade)
#+end_src


** Code snippets
*** Be careful of macros
#+begin_src clojure
;; works
(let [f #(inc %)]
  (some-> 1 f))
;; doesn't work
(some-> 1 #(inc %))
#+end_src
*** Query and filter classpath
#+begin_src 
(filter #(.contains % "clojure") (clojure.string/split (System/getProperty "java.class.path") #"\:"))
#+end_src
*** Get methods out of instance
#+begin_src clojure

; useful fucntion
(use 'clojure.reflect)
(defn methods [obj]
  (->> (reflect obj)
      :members
      (map #(select-keys % [:name]))))

#+end_src
*** Get methods out of class
https://clojuredocs.org/clojure.reflect/type-reflect
#+begin_src clojure
(use 'clojure.reflect)

(->> java.lang.Integer 
     clojure.reflect/type-reflect
     :members 
     (filter #(instance? clojure.reflect.Field %)) 
     (filter #(:public (:flags %)))
     (filter #(:static (:flags %)))
     (map #(vector (:name %) (:type %)))
     (sort)
     (pprint))

;;=> ([BYTES int]
;;    [MAX_VALUE int]
;;    [MIN_VALUE int]
;;    [SIZE int]
;;    [TYPE java.lang.Class])
#+end_src
*** Print stacktrace
(clojure.stacktrace/print-stack-trace (Exception. "foo"))
** Tools + libs
*** https://github.com/dgrnbrg/spyscope
*** Scala interop lib https://t6.github.io/from-scala/
** Gotchas
*** Autoresolution of keywords '::'  https://groups.google.com/forum/#!topic/clojure/i770QaIFiF0
*** IllegalArgument with no help https://stackoverflow.com/questions/19590432/why-does-clojure-say-no-matching-method-for-an-illegal-argument
- This could happen when passing nil to a primitive parameter in java.
- Find this out by instrumenting the calling method in cider or equivalent.
*** Equivalent https://clojureverse.org/t/1-2-equals-1-2/821/4
** Don'ts (as recommended by Stuart)
*** Threading of as-> https://stuartsierra.com/2018/07/15/clojure-donts-thread-as
** Idiomatic clojure
*** Depth first iteration and dispatch encapsulation hell!
If computer programs were artistic styles, then procedural programs would complete a drawing by tracing the outline, while clojure would build up a drawing from smaller shapes. Both methods would complete a drawing accurately.

When building up a program from idiomatic clojure, be careful to slip back into procedural ways
of doing things.


Consider the example below which is no doubt contrived but it's not diffficult to add 
extra criterion justifying the separation. Indeed the layout is not foreign and could
be simplified further only given there are no further dependencies.
#+begin_src clojure
(defn output-valid-hash! [m]
  (when (> (:hash m) -1695810776)
    (println m)
     )
  )

(defn output-hashed!
  [m]
  (output-valid-hash!
   (assoc m :hash (some-> m :name hash))
                      )
  )

(defn output-names!
  [names]
  ;; Imagine this is long and complicated
  (doseq [n names]
    (output-hashed! (assoc {} :name n))
    )
  )

(output-names! ["John" "James" "Michael"])

#+end_src


The above only prints a record for Michael and you want to confirm why.
In this case you may suspect the when around the println, but you want to test it easily.
Perhaps it may also be assumptions about the creation of the map values.


It's quite hard to test this code, because at each level there is some unpacking and repacking.
There is a mental burden of understanding the context at each level.
Having to rely on a debugger is not ideal.
It's possible to make code changes to test the results, but these changes are distributed, making
them error prone.

It's positive that this code is depth first. It doesn't start processing the second name until the first is completed. It could potentially work on a stream of names,
but addressing them one at a time.
It can also be argued that the functions are available for processing code at different levels of completeness.

Compare this to the clojure idiomatic:

#+begin_src clojure
(->> ["John" "James" "Michael"]
     (map #(if (string? %)
             (assoc {} :name %)
             %)
          )
     (map #(assoc % :hash (hash (:name %))))
     (filter #(> (:hash %) -1695810776))
     (println)
     )
#+end_src

Advantages:
- Can operate on a stream of strings or maps with :name already.
- It's possible to comment out the filter in one line and see the result.
- Can see the result to the repl by commenting out the println (Dont' need to change the
return values of the functions).

NOTE this is only possible with Clojure's laziness model. Otherwise this pipeline would not be depth first and not appropriate for streams! It's also only possible in this 

Java streams can help as an equivalence but there be dragons  https://jaxenter.com/java-8-streams-lazy-136183.html
https://4comprehension.com/java-stream-api-was-broken-before-jdk10/

** Interesting reads
*** Transient data structures https://clojure.org/reference/transients
*** Missing elegant API for manipulating immutable data structures http://nathanmarz.com/blog/clojures-missing-piece.html
*** Clojure workflow tips https://clojureverse.org/t/share-the-nitty-gritty-details-of-your-clojure-workflow/1208/23
*** Reloading woes https://lambdaisland.com/blog/2018-02-09-reloading-woes
*** Nested hash map anti pattern? (Only required in rare circumstances) https://hackernoon.com/nested-maps-considered-harmful-143add482247
*** Nil punning https://lispcast.com/nil-punning/
*** Interesting threading https://www.spacjer.com/blog/2015/11/09/lesser-known-clojure-variants-of-threading-macro/
*** Maps vs records  http://discuss.purelyfunctional.tv/t/when-to-use-map-vs-defrecord/933
*** Keywords vs Symbols https://blog.robphoenix.com/clojure/notes-on-clojure-keywords-symbols/
*** gen-class
Overview
https://kotka.de/blog/2010/02/gen-class_how_it_works_and_how_to_use_it.html
More on gen-class
https://stackoverflow.com/questions/42617678/gen-class-in-clojure-and-use-it-immediately

Official documentation with examples!
https://clojure.org/reference/compilation

See class loading issues
*** Class loading issues with generated classes
https://medium.com/@minfuyang/about-java-classloader-dynamic-class-generation-in-apache-spark-case-43a6d492c78f
*** Subclassing https://puredanger.github.io/tech.puredanger.com/2011/08/12/subclassing-in-clojure/
*** Proxying abstract classes https://stackoverflow.com/questions/53090419/clojure-proxy-implementing-abstract-class-with-protected-constructor
*** Logging https://juxt.pro/blog/posts/logging.html
*** Clojure safety information in the following comments http://clojuredocs.org/clojure.core/read
*** No lazy vectors in clojure https://stackoverflow.com/questions/3083535/clojure-lazy-sequences-that-are-vectors
*** Macro expansion warning https://ask.clojure.org/index.php/9015/spec-error-on-simple-threading-in-clj-cljs
*** Datafy & Nav http://corfield.org/blog/2018/12/03/datafy-nav
https://ask.clojure.org/index.php/8550/can-someone-explain-the-arguments-to-nav
*** Clojure slow startup time http://clojure-goes-fast.com/blog/clojures-slow-start/
Follow up and patch here
https://groups.google.com/g/clojure/c/jNWf19LvszU/m/iKZSKVLBAgAJ
https://github.com/forax/clojure
*** Java decompilation http://clojure-goes-fast.com/blog/introspection-tools-java-decompilers/
*** Deps & Cli limitations https://clojureverse.org/t/how-to-effectively-use-deps-cli/4787/4
And supplementations https://github.com/clojure/tools.deps.alpha/wiki/Tools
*** Specter vs Transducer code sample https://gist.github.com/borkdude/5f9a4ae710217e893a9462ff90b6cac3
*** Decompiling Clojure (3 parts)  http://blog.guillermowinkler.com/blog/2014/04/13/decompiling-clojure-i/
*** Equivalent of node.js non-blocking? https://stackoverflow.com/questions/24980014/can-i-make-a-fully-non-blocking-backend-application-with-http-kit-and-core-async
*** TODO Datomic vs GraphQL https://www.indiehackers.com/post/a-time-saving-alternative-for-graphql-da674d0961
https://maxweber.github.io/blog/2019-06-15-approaching-the-web-after-tomorrow-part-3
https://maxweber.github.io/blog/2019-08-05-introducing-db-view-part-2
*** Flatten, apply concat & friends http://chouser.n01se.net/apply-concat/
And some playing around
#+begin_src clojure
(def y
  (for [x ["sdfasf" "adfa" "erqewr"]]
    (seq x))
  )

(identity y) ;; => ((\s \d \f \a \s \f) (\a \d \f \a) (\e \r \q \e \w \r))
(map type y) ;; => (clojure.lang.StringSeq clojure.lang.StringSeq clojure.lang.StringSeq)
(apply concat y)
#+end_src
** Cider
*** cider hook http://root42.blogspot.com/2014/08/how-to-automatically-refresh-cider-when.html
*** Making clojure lazier & streams https://clojure.org/reference/lazy
*** Deep dive into sequences
Easy start with: https://medium.com/@pwentz/laziness-in-clojure-3d83645bf7f3

More concisely: https://insideclojure.org/2015/01/02/sequences/

Then to pick apart the details of types: https://stackoverflow.com/questions/44095400/how-to-understand-clojures-lazy-seq/44102122

** Videos
*** TODO Task : Make a doubly nested for loop, calling on a Java API (XLS) spreadsheet, to take a data structure and save it to tables.
https://github.com/mjul/docjure

The naive way that a java programmer would code:
- Assuming the need for for counters.
- There is a need for counters. Docjure got around it by querying the underlying data!
- Made a mistake for vs deseq
- Made a mistake or at least didn't realize that I'd reached the point to start breaking functions up. This is good!
- At least we figured out map-indexed!

#+begin_src clojure
(defn save-excel! []
  (println "saving excel spreadsheet")
  (let [workbook (XSSFWorkbook.)
        sheet (.createSheet workbook "Datatypes in Java")
        datatypes [["Datatypes", "Type", "Size(in bytes)"]
                   ["int", "Primitive", 2]
                   ["float", "Primitive", 4]
                   ["double", "Primitive", 8]
                   ["char", "Primitive", 1]
                   ["String", "Non-Primitive", "No fixed size"]]
        rowNum 0

        ]
    (for [row_data datatypes
          :let [row (. sheet createRow rowNum)
                ]]
      ;; The following causes a side effect
      (dorun (map-indexed  #(let [cell (. row createCell (inc %1))] (.setCellValue cell %2)
                          )
                    row_data))
      )
    (try (doto workbook (.write (FileOutputStream. "myfile.xls")) (.close))
         (catch Exception e (.printStackTrace e)))
    )
  )


(save-excel!)
#+end_src
*** Scope capture https://vimeo.com/237220354
*** Clojure for ETLs https://www.youtube.com/watch?v=oOON--g1PyU
** Improvements
*** Ensure that stacktrace window is colour coded obvious to communicate whether it's a runtime error or compile time error.
*** Thread about how to compensate for the lack of dot https://www.reddit.com/r/Clojure/comments/6f6cq2/how_to_compensate_for_clojures_lack_of_dot/
*** The stacktrace window should allow one ot preview items without go
*** To clojurephant
; (in [1 2] 1) ; like .contains
; (expand-case) to expand out case test-contants.


